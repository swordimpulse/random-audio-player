<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Random Audio Player (for iPhone)</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo;padding:14px;max-width:900px;margin:auto}
  input,button{font-size:16px;margin:6px 0;padding:8px}
  .file-row{display:flex;align-items:center;gap:8px;margin:6px 0;padding:6px;border:1px solid #ddd;border-radius:6px}
  .file-name{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .controls{margin-top:12px}
  label.small{font-size:13px;color:#555}
  .status{margin-top:10px;color:#006}
  @media(max-width:480px){ .file-row{flex-direction:column;align-items:flex-start} }
</style>
</head>
<body>
  <h2>Random Audio Player（Google Sites 埋め込み用）</h2>
  <p>使い方：音声ファイルを選択して「Start Loop」を押すと、ランダムで1つ選んで再生→再生終了後に指定した範囲内で待機→次、を繰り返します。個別再生も可能。</p>

  <div>
    <input id="fileInput" type="file" accept="audio/*" multiple>
    <div>
      <label class="small">または外部音声URLを追加：</label><br>
      <input id="urlInput" type="url" placeholder="https://example.com/sound.mp3" style="width:70%">
      <button id="addUrlBtn">Add URL</button>
    </div>
  </div>

  <div style="margin-top:10px">
    Min delay (s): <input id="minDelay" type="number" value="2" min="0" style="width:80px">
    Max delay (s): <input id="maxDelay" type="number" value="10" min="0" style="width:80px">
    <label class="small">（待機はランダム、指定範囲内）</label>
  </div>

  <div class="controls">
    <button id="startLoop">Start Loop</button>
    <button id="stopLoop">Stop</button>
    <button id="pauseBtn">Pause/Resume</button>
  </div>

  <div id="list" style="margin-top:12px"></div>

  <div class="status" id="status">Status: stopped</div>

<script>
(() => {
  const fileInput = document.getElementById('fileInput');
  const listEl = document.getElementById('list');
  const startLoopBtn = document.getElementById('startLoop');
  const stopLoopBtn = document.getElementById('stopLoop');
  const pauseBtn = document.getElementById('pauseBtn');
  const minDelayEl = document.getElementById('minDelay');
  const maxDelayEl = document.getElementById('maxDelay');
  const statusEl = document.getElementById('status');
  const urlInput = document.getElementById('urlInput');
  const addUrlBtn = document.getElementById('addUrlBtn');

  let items = []; // {name, url, objectUrl:boolean}
  const audio = new Audio();
  audio.preload = 'auto';
  let loopRunning = false;
  let paused = false;
  let loopController = { stopRequested:false };

  function updateStatus(t) { statusEl.textContent = 'Status: ' + t; }

  function createRow(item, idx) {
    const row = document.createElement('div');
    row.className = 'file-row';
    const name = document.createElement('div');
    name.className = 'file-name';
    name.textContent = item.name;
    row.appendChild(name);

    const playBtn = document.createElement('button');
    playBtn.textContent = 'Play';
    playBtn.onclick = () => playSingle(idx);
    row.appendChild(playBtn);

    const setNextBtn = document.createElement('button');
    setNextBtn.textContent = 'Play Next';
    setNextBtn.onclick = () => { playSingle(idx).then(()=>{}); }; // same as Play
    row.appendChild(setNextBtn);

    const removeBtn = document.createElement('button');
    removeBtn.textContent = 'Remove';
    removeBtn.onclick = () => {
      if (items[idx].objectUrl) URL.revokeObjectURL(items[idx].url);
      items.splice(idx,1);
      renderList();
    };
    row.appendChild(removeBtn);

    return row;
  }

  function renderList(){
    listEl.innerHTML = '';
    if (items.length === 0) {
      listEl.textContent = '(No audio files added)';
      return;
    }
    items.forEach((it, i) => {
      listEl.appendChild(createRow(it,i));
    });
  }

  fileInput.addEventListener('change', (e) => {
    const files = Array.from(e.target.files || []);
    files.forEach(f => {
      const url = URL.createObjectURL(f);
      items.push({name: f.name, url, objectUrl:true});
    });
    renderList();
  });

  addUrlBtn.addEventListener('click', () => {
    const u = urlInput.value.trim();
    if (!u) return alert('URL を入力してください');
    // basic check
    items.push({name: u.split('/').pop() || u, url: u, objectUrl:false});
    urlInput.value = '';
    renderList();
  });

  async function playSingle(index) {
    if (!items[index]) return;
    try {
      audio.src = items[index].url;
      audio.currentTime = 0;
      updateStatus('Playing: ' + items[index].name);
      await audio.play(); // must be called after user gesture at least once on iOS
      // return a promise that resolves when ended or error
      return await new Promise(resolve => {
        audio.onended = () => { updateStatus('Ended: ' + items[index].name); resolve(); };
        audio.onerror = () => { updateStatus('Error playing: ' + items[index].name); resolve(); };
      });
    } catch(err) {
      updateStatus('Play error: ' + err);
      console.error(err);
    }
  }

  function randInt(min, max) {
    min = Math.ceil(min); max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  async function playLoop() {
    // this function runs until loopController.stopRequested becomes true
    loopController.stopRequested = false;
    loopRunning = true;
    updateStatus('Loop started');
    while (!loopController.stopRequested) {
      if (items.length === 0) { updateStatus('No items — stopping'); break; }
      // pick random
      const idx = Math.floor(Math.random() * items.length);
      await playSingle(idx);
      if (loopController.stopRequested) break;

      // wait random delay
      let minD = Number(minDelayEl.value) || 0;
      let maxD = Number(maxDelayEl.value) || minD;
      if (minD > maxD) { const t=minD; minD=maxD; maxD=t; }
      const waitSec = (minD === maxD) ? minD : (Math.random() * (maxD - minD) + minD);
      updateStatus(`Played "${items[idx].name}". Waiting ${waitSec.toFixed(2)}s...`);
      const start = performance.now();
      // waiting loop respects pause button
      while ((performance.now() - start) < waitSec*1000) {
        if (loopController.stopRequested) break;
        if (paused) { await new Promise(r => setTimeout(r, 200)); continue; }
        await new Promise(r => setTimeout(r, 200));
      }
    }
    loopRunning = false;
    updateStatus('Loop stopped');
  }

  startLoopBtn.addEventListener('click', (e) => {
    // user gesture - allows audio.play on iOS
    if (loopRunning) { alert('Already running'); return; }
    playLoop(); // no await - background loop
  });

  stopLoopBtn.addEventListener('click', () => {
    loopController.stopRequested = true;
    audio.pause();
    audio.src = '';
    paused = false;
    updateStatus('Stopping...');
  });

  pauseBtn.addEventListener('click', () => {
    if (!loopRunning) {
      // toggles audio pause/resume for single playback as well
      if (audio.paused) { audio.play(); paused = false; updateStatus('Resumed'); }
      else { audio.pause(); paused = true; updateStatus('Paused'); }
      return;
    }
    paused = !paused;
    if (paused) {
      audio.pause();
      updateStatus('Loop paused');
    } else {
      audio.play().catch(()=>{}); // may fail if no current src
      updateStatus('Loop resumed');
    }
  });

  // cleanup objectURLs when leaving
  window.addEventListener('beforeunload', () => {
    items.forEach(i => { if (i.objectUrl) URL.revokeObjectURL(i.url); });
  });

  renderList();
})();
</script>
</body>
</html>
