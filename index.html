<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Random Audio Player (with checkboxes & persistence)</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo;padding:14px;max-width:1000px;margin:auto}
  input,button{font-size:15px;margin:6px 0;padding:8px}
  .file-row{display:flex;align-items:center;gap:8px;margin:6px 0;padding:6px;border:1px solid #eee;border-radius:6px}
  .file-name{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .controls{margin-top:12px}
  label.small{font-size:13px;color:#555}
  .status{margin-top:10px;color:#006}
  .mini{font-size:13px;padding:6px}
  @media(max-width:480px){ .file-row{flex-direction:column;align-items:flex-start} }
</style>
</head>
<body>
  <h2>Random Audio Player（チェック＋保存対応）</h2>
  <p>音声を追加 → チェックしたものだけループ再生（再読み込みで復元）。外部URLも追加可。</p>

  <div>
    <input id="fileInput" type="file" accept="audio/*" multiple>
    <div style="margin-top:6px">
      <input id="urlInput" type="url" placeholder="https://example.com/sound.mp3" style="width:68%">
      <button id="addUrlBtn">Add URL</button>
    </div>
  </div>

  <div style="margin-top:8px">
    Min delay (s): <input id="minDelay" type="number" value="2" min="0" style="width:80px">
    Max delay (s): <input id="maxDelay" type="number" value="10" min="0" style="width:80px">
  </div>

  <div class="controls">
    <button id="startLoop">Start Loop</button>
    <button id="stopLoop">Stop</button>
    <button id="pauseBtn">Pause/Resume</button>
    <button id="selectAll" class="mini">Select All</button>
    <button id="deselectAll" class="mini">Deselect All</button>
    <button id="invertSel" class="mini">Invert</button>
    <button id="clearStored" class="mini">Clear saved data</button>
  </div>

  <div id="list" style="margin-top:12px"></div>
  <div class="status" id="status">Status: stopped</div>

<script>
(async () => {
  // ========== IndexedDB helper ==========
  function openDb() {
    return new Promise((resolve, reject) => {
      const rq = indexedDB.open('audio-store', 1);
      rq.onupgradeneeded = (ev) => {
        const db = rq.result;
        if (!db.objectStoreNames.contains('files')) {
          db.createObjectStore('files', {keyPath: 'id'});
        }
      };
      rq.onsuccess = () => resolve(rq.result);
      rq.onerror = () => reject(rq.error);
    });
  }

  async function idbPutFile(entry) {
    const db = await openDb();
    return new Promise((res, rej) => {
      const tx = db.transaction('files','readwrite');
      const store = tx.objectStore('files');
      store.put(entry);
      tx.oncomplete = () => res();
      tx.onerror = () => rej(tx.error);
    });
  }
  async function idbGetAll() {
    const db = await openDb();
    return new Promise((res, rej) => {
      const tx = db.transaction('files','readonly');
      const store = tx.objectStore('files');
      const rq = store.getAll();
      rq.onsuccess = () => res(rq.result || []);
      rq.onerror = () => rej(rq.error);
    });
  }
  async function idbDelete(id) {
    const db = await openDb();
    return new Promise((res, rej) => {
      const tx = db.transaction('files','readwrite');
      tx.objectStore('files').delete(id);
      tx.oncomplete = () => res();
      tx.onerror = () => rej(tx.error);
    });
  }

  // ========== app state ==========
  const fileInput = document.getElementById('fileInput');
  const listEl = document.getElementById('list');
  const startLoopBtn = document.getElementById('startLoop');
  const stopLoopBtn = document.getElementById('stopLoop');
  const pauseBtn = document.getElementById('pauseBtn');
  const minDelayEl = document.getElementById('minDelay');
  const maxDelayEl = document.getElementById('maxDelay');
  const statusEl = document.getElementById('status');
  const urlInput = document.getElementById('urlInput');
  const addUrlBtn = document.getElementById('addUrlBtn');
  const selectAllBtn = document.getElementById('selectAll');
  const deselectAllBtn = document.getElementById('deselectAll');
  const invertSelBtn = document.getElementById('invertSel');
  const clearStoredBtn = document.getElementById('clearStored');

  const audio = new Audio();
  audio.preload = 'auto';

  // items: {id, name, url, objectUrl, checked, storedAsBlob(bool)}
  let items = [];
  let loopRunning = false;
  let paused = false;
  let loopController = { stopRequested:false };

  // localStorage key for metadata (URLs and item list except blobs)
  const META_KEY = 'random-audio-meta-v1';

  function updateStatus(t) { statusEl.textContent = 'Status: ' + t; saveMeta(); }

  function saveMeta() {
    // Save items metadata (excluding large blobs). For items that are blob-stored, we still save id/name/checked
    try {
      const meta = items.map(it => ({
        id: it.id,
        name: it.name,
        url: it.storedAsBlob ? null : it.url,
        storedAsBlob: !!it.storedAsBlob,
        checked: !!it.checked
      }));
      localStorage.setItem(META_KEY, JSON.stringify({items: meta, minDelay: minDelayEl.value, maxDelay: maxDelayEl.value}));
    } catch(e) { console.warn('saveMeta failed', e); }
  }

  async function loadMeta() {
    // load metadata and reconstruct items list; for blob-stored items, read from IDB
    try {
      const raw = localStorage.getItem(META_KEY);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (parsed.minDelay) minDelayEl.value = parsed.minDelay;
      if (parsed.maxDelay) maxDelayEl.value = parsed.maxDelay;
      const metaItems = parsed.items || [];
      // get all blobs in DB
      const blobs = await idbGetAll(); // entries have {id, name, blob}
      // create a map by id
      const blobMap = new Map(blobs.map(b => [b.id, b]));
      // reconstruct items
      items = metaItems.map(m => {
        if (m.storedAsBlob && blobMap.has(m.id)) {
          const entry = blobMap.get(m.id);
          const objUrl = URL.createObjectURL(entry.blob);
          return {id: m.id, name: m.name || entry.name, url: objUrl, objectUrl:true, checked: !!m.checked, storedAsBlob:true};
        } else if (!m.storedAsBlob && m.url) {
          return {id: m.id, name: m.name || m.url.split('/').pop(), url: m.url, objectUrl:false, checked: !!m.checked, storedAsBlob:false};
        } else {
          // blob missing or invalid: skip
          return null;
        }
      }).filter(Boolean);
      renderList();
    } catch(e){ console.warn('loadMeta failed',e); }
  }

  // UI rendering
  function createRow(item, idx) {
    const row = document.createElement('div');
    row.className = 'file-row';
    const chk = document.createElement('input');
    chk.type = 'checkbox';
    chk.checked = !!item.checked;
    chk.onchange = () => { item.checked = chk.checked; saveMeta(); };
    row.appendChild(chk);

    const name = document.createElement('div');
    name.className = 'file-name';
    name.textContent = item.name;
    row.appendChild(name);

    const playBtn = document.createElement('button');
    playBtn.textContent = 'Play';
    playBtn.onclick = () => playSingle(idx);
    row.appendChild(playBtn);

    const removeBtn = document.createElement('button');
    removeBtn.textContent = 'Remove';
    removeBtn.onclick = async () => {
      // remove from items; if storedAsBlob -> delete from IDB
      const id = item.id;
      if (item.objectUrl) URL.revokeObjectURL(item.url);
      items.splice(idx,1);
      if (item.storedAsBlob) {
        try { await idbDelete(id); } catch(e){ console.warn('idb delete failed', e); }
      }
      renderList();
      saveMeta();
    };
    row.appendChild(removeBtn);

    const note = document.createElement('div');
    note.style.fontSize='12px'; note.style.color='#666'; note.textContent = item.storedAsBlob ? ' (local saved)' : (item.objectUrl ? ' (temp)' : ' (url)');
    row.appendChild(note);

    return row;
  }

  function renderList(){
    listEl.innerHTML = '';
    if (items.length === 0) { listEl.textContent = '(No audio files added)'; return; }
    items.forEach((it, i) => listEl.appendChild(createRow(it, i)));
  }

  // adding URL
  addUrlBtn.addEventListener('click', () => {
    const u = urlInput.value.trim();
    if (!u) return alert('URL を入力してください');
    const id = 'url_'+Date.now()+'_'+Math.floor(Math.random()*10000);
    items.push({id, name: u.split('/').pop() || u, url: u, objectUrl:false, checked:true, storedAsBlob:false});
    urlInput.value='';
    renderList();
    saveMeta();
  });

  // adding local files: save to IDB as blob and create objectURL
  fileInput.addEventListener('change', async (e) => {
    const files = Array.from(e.target.files || []);
    if (files.length === 0) return;
    for (const f of files) {
      const id = 'file_'+Date.now()+'_'+Math.floor(Math.random()*10000);
      const entry = {id, name: f.name, blob: f};
      try {
        await idbPutFile(entry); // store blob
        const objUrl = URL.createObjectURL(f);
        items.push({id, name: f.name, url: objUrl, objectUrl:true, checked:true, storedAsBlob:true});
      } catch(err) {
        console.warn('IDB put failed, falling back to temp URL', err);
        const objUrl = URL.createObjectURL(f);
        items.push({id, name: f.name, url: objUrl, objectUrl:true, checked:true, storedAsBlob:false});
      }
    }
    renderList();
    saveMeta();
    // reset file input so same file can be re-selected later if needed
    fileInput.value = '';
  });

  // playback functions
  async function playSingle(index) {
    const item = items[index];
    if (!item) return;
    try {
      audio.src = item.url;
      audio.currentTime = 0;
      updateStatus('Playing: ' + item.name);
      await audio.play();
      return await new Promise(resolve => {
        audio.onended = () => { updateStatus('Ended: ' + item.name); resolve(); };
        audio.onerror = () => { updateStatus('Error playing: ' + item.name); resolve(); };
      });
    } catch(err) {
      console.error(err);
      updateStatus('Play error: ' + err);
    }
  }

  function randFloat(min,max){ return Math.random()*(max-min)+min; }

  async function playLoop() {
    loopController.stopRequested = false;
    loopRunning = true;
    updateStatus('Loop started');
    while (!loopController.stopRequested) {
      const playables = items.filter(it => it.checked);
      if (playables.length === 0) { updateStatus('No checked items — stopping'); break; }
      // random pick
      const idxInPlay = Math.floor(Math.random()*playables.length);
      const item = playables[idxInPlay];
      // find index in items array to use playSingle (we need index)
      const globalIdx = items.findIndex(it => it.id === item.id);
      if (globalIdx === -1) { updateStatus('Item not found'); break; }
      await playSingle(globalIdx);
      if (loopController.stopRequested) break;
      // wait random
      let minD = Number(minDelayEl.value) || 0;
      let maxD = Number(maxDelayEl.value) || minD;
      if (minD > maxD) { const t=minD; minD=maxD; maxD=t; }
      const waitSec = (minD === maxD) ? minD : randFloat(minD, maxD);
      updateStatus(`Played "${item.name}". Waiting ${waitSec.toFixed(2)}s...`);
      const start = performance.now();
      while ((performance.now() - start) < waitSec*1000) {
        if (loopController.stopRequested) break;
        if (paused) { await new Promise(r => setTimeout(r, 200)); continue; }
        await new Promise(r => setTimeout(r, 200));
      }
    }
    loopRunning = false;
    updateStatus('Loop stopped');
  }

  startLoopBtn.addEventListener('click', () => {
    if (loopRunning) { alert('Already running'); return; }
    // initial user gesture allows audio.play on iOS
    playLoop();
  });
  stopLoopBtn.addEventListener('click', () => {
    loopController.stopRequested = true;
    audio.pause();
    audio.src = '';
    paused = false;
    updateStatus('Stopping...');
  });
  pauseBtn.addEventListener('click', () => {
    if (!loopRunning) {
      if (audio.paused) { audio.play(); paused=false; updateStatus('Resumed'); }
      else { audio.pause(); paused=true; updateStatus('Paused'); }
      return;
    }
    paused = !paused;
    if (paused) { audio.pause(); updateStatus('Loop paused'); }
    else { audio.play().catch(()=>{}); updateStatus('Loop resumed'); }
  });

  selectAllBtn.addEventListener('click', () => { items.forEach(it=>it.checked=true); renderList(); saveMeta(); });
  deselectAllBtn.addEventListener('click', () => { items.forEach(it=>it.checked=false); renderList(); saveMeta(); });
  invertSelBtn.addEventListener('click', () => { items.forEach(it=>it.checked=!it.checked); renderList(); saveMeta(); });

  clearStoredBtn.addEventListener('click', async () => {
    if (!confirm('保存されたデータ（ブラウザ内）をすべて消します。よいですか？')) return;
    try {
      // clear localStorage meta
      localStorage.removeItem(META_KEY);
      // clear IDB
      const db = await openDb();
      const tx = db.transaction('files','readwrite');
      tx.objectStore('files').clear();
      tx.oncomplete = () => {
        // revoke object URLs
        items.forEach(i => { if (i.objectUrl) URL.revokeObjectURL(i.url); });
        items = [];
        renderList();
        updateStatus('Cleared saved data');
      };
      tx.onerror = () => { alert('Failed to clear IndexedDB: ' + tx.error); };
    } catch(e){ alert('Clear failed: ' + e); console.warn(e); }
  });

  // load saved data on start
  try { await loadMeta(); } catch(e){ console.warn('loadMeta error', e); }
  renderList();

  // cleanup on unload
  window.addEventListener('beforeunload', () => {
    items.forEach(i => { if (i.objectUrl) URL.revokeObjectURL(i.url); });
  });

})();
</script>
</body>
</html>
